from dsi import UtilsTypefrom os.path import isfile, getsize, joinfrom os import walk, listdir, sepimport platformimport sysfrom FolderSize import FolderSizeimport threadingimport timeimport java.lang.Runtime as runtimefrom java.util.concurrent import Executors, TimeUnitfrom java.lang import Thread as Thread#class Utils(UtilsType):# class Utils(object):   def __init__(self, path):      self.path = path      self.errors = ''      self.cores = runtime.getRuntime().availableProcessors()   def sizeof_fmt(self, num):       for x in [' B',' KB',' MB',' GB']:           if num < 1024.0:               return "%3.1f%s" % (num, x)           num /= 1024.0       return "%3.1f%s" % (num, 'TB')   def get_free_space(self):       """ Return folder/drive free space (in bytes)       """       import java.lang.reflect.Array       import java.io.File       roots = java.io.File.listRoots()       rows = len(roots) * 4       str2d = java.lang.reflect.Array.newInstance(java.lang.String,[rows, 2])       row_count = 0       for i in roots:           str2d[row_count][0] = str(i)           str2d[row_count][1] = 'Total capacity: ' + self.sizeof_fmt(i.getTotalSpace())           row_count += 1           str2d[row_count][1] = 'Used Space:  ' + self.sizeof_fmt(i.getTotalSpace() - i.getFreeSpace())           row_count += 1           str2d[row_count][1] = 'Free Space:  ' + self.sizeof_fmt(i.getFreeSpace())           row_count += 2       return str2d   def get_dir_size(self, file_or_folder):       # FolderSize.total_size = 0       # start_time = time.time()       # print file_or_folder       if isfile(file_or_folder):           # print file_or_folder           return getsize(file_or_folder)       pool = Executors.newCachedThreadPool(self.cores)       # print 'checking folder: ' + file_or_folder       ff= []       try:           for f in listdir(file_or_folder):               ff.append(FolderSize(join(file_or_folder, f)))       except Exception, e:           print e       futures = pool.invokeAll(ff)       total = 0       for future in futures:           f = future.get(100, TimeUnit.SECONDS)           # print 'f.folder: ', f.folder, 'f.total_size:' , f.total_size           # time.sleep(5)           total += f.total_size       self.shutdown_and_await_termination(pool, 100)       # print time.time() - start_time, "seconds"       # print 'total: ' + FolderSize.total_size       return total   def shutdown_and_await_termination(self, pool, timeout):       pool.shutdown()       try:           if not pool.awaitTermination(timeout, TimeUnit.SECONDS):               pool.shutdownNow()               if (not pool.awaitTermination(timeout, TimeUnit.SECONDS)):                   print >> sys.stderr, "Pool did not terminate"       except Exception, ex:           print 'exception' + ex           # (Re-)Cancel if current thread also interrupted           pool.shutdownNow()           # Preserve interrupt status           Thread.currentThread().interrupt()   def get_errors(self):       return self.errorsdef main():    path = '/Users/snasrallah/share'    utils = Utils(path)    start_time = time.time()    print utils.sizeof_fmt(utils.get_dir_size(path))    # #print('%s = %s \n' % (path, Utils(path).getFolderSizes()))    # print(utils.get_free_space())    # folder = "/Users/snasrallah"    # print utils.sizeof_fmt(utils.get_dir_size(path))    print time.time() - start_time, "seconds"if __name__ == "__main__":    main()